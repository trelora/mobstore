{
    "docs": [
        {
            "location": "/", 
            "text": "Links\n\n\n\n\nSource Code on Github\n\n\nNPM Package\n\n\n\n\nDescription\n\n\nMobStore is a data-store layer for reactive javascript applications.\n\n\nMobStore is a thin layer on top of the brilliant Transparent Functional Reactive Programming library MobX. See \nMobX (formerly mobservable)\n for more information.\n\n\nMobStore takes hierarchical JSON data and turns it back into a graph.\n\n\nMobStore automatically hooks up bidirectional, potentially circular references based on the associations you define, and makes the entire graph reactive, so you can change any part of your data and see the results in your UI immediately.\n\n\nMobStore is an alternative to Flux/Redux. The unidirectional data-flow is still there, but instead of having a Rube Goldberg machine of action creators and reducers in order to change your data, you can just call a method. And there's no need to flatten your data or deal with a global state tree. You can have a proper graph of data on the client.\n\n\nCurrent status\n\n\nThis is being used in production at Trelora, inc. It works great for our needs. However, we have only added the features we need as we need them, so there is probably still missing functionality.\n\n\nMissing features\n\n\n\n\nThere is currently no way to remove data from a store. TODO: \nmyStore.eject(id_or_ids)\n, \nmyStore.clear()\n\n\nThere is no automatic way to inject data formatted in HAL, JSONAPI, etc. Would be nice to add a parser/adapter layer to be able to easily inject different data formats.\n\n\nMobStore does not do any server communication. Not sure whether it ever will, but currently getting the actual data is up to you.\n\n\nWhat else? File an issue.\n\n\n\n\nHello MobStore\n\n\nimport {MobStore} from 'mobstore';\n\nconst itemStore = new MobStore({\n  collectionName: 'items',\n  type: 'item'\n});\n\nitemStore.inject({id: 1, name: \nitem one\n})\n\nitemStore.items\n// =\n [{id: 1, name: \nitem one\n}]\n\nitemStore.find(1)\n// =\n {id: 1, name: \nitem one\n}", 
            "title": "Home"
        }, 
        {
            "location": "/#links", 
            "text": "Source Code on Github  NPM Package", 
            "title": "Links"
        }, 
        {
            "location": "/#description", 
            "text": "MobStore is a data-store layer for reactive javascript applications.  MobStore is a thin layer on top of the brilliant Transparent Functional Reactive Programming library MobX. See  MobX (formerly mobservable)  for more information.  MobStore takes hierarchical JSON data and turns it back into a graph.  MobStore automatically hooks up bidirectional, potentially circular references based on the associations you define, and makes the entire graph reactive, so you can change any part of your data and see the results in your UI immediately.  MobStore is an alternative to Flux/Redux. The unidirectional data-flow is still there, but instead of having a Rube Goldberg machine of action creators and reducers in order to change your data, you can just call a method. And there's no need to flatten your data or deal with a global state tree. You can have a proper graph of data on the client.", 
            "title": "Description"
        }, 
        {
            "location": "/#current-status", 
            "text": "This is being used in production at Trelora, inc. It works great for our needs. However, we have only added the features we need as we need them, so there is probably still missing functionality.", 
            "title": "Current status"
        }, 
        {
            "location": "/#missing-features", 
            "text": "There is currently no way to remove data from a store. TODO:  myStore.eject(id_or_ids) ,  myStore.clear()  There is no automatic way to inject data formatted in HAL, JSONAPI, etc. Would be nice to add a parser/adapter layer to be able to easily inject different data formats.  MobStore does not do any server communication. Not sure whether it ever will, but currently getting the actual data is up to you.  What else? File an issue.", 
            "title": "Missing features"
        }, 
        {
            "location": "/#hello-mobstore", 
            "text": "import {MobStore} from 'mobstore';\n\nconst itemStore = new MobStore({\n  collectionName: 'items',\n  type: 'item'\n});\n\nitemStore.inject({id: 1, name:  item one })\n\nitemStore.items\n// =  [{id: 1, name:  item one }]\n\nitemStore.find(1)\n// =  {id: 1, name:  item one }", 
            "title": "Hello MobStore"
        }, 
        {
            "location": "/overview/", 
            "text": "Setup\n\n\nHere's an example where we set up three data stores, each with associations to the other two. Notice that we are very explicit about the associations we set up. Nothing is magic. Only the associations you define are populated.\n\n\nimport {MobStore} from 'mobstore';\n\nconst postStore = new MobStore({\n  collectionName: \nposts\n,  // the accessor, i.e. `postStore.posts`\n  type: \npost\n,             // this store holds items of the `post` type.\n  associations: [\n    {\n      key: \ncomments\n,      // a post has a `myPost.comments` key\n      type: \ncomment\n,      // this association holds items of the `comment` type.\n      plural: true,         // it's an array of them, not a single one.\n      inverse: {\n        key: \npost\n,        // a comment will have a `myComment.post` key\n        plural: false       // optional, false is the default\n      }\n    },\n    {\n      key: \nauthor\n,\n      type: \nperson\n,\n      plural: false,\n      inverse: {\n        key: \nposts\n,\n        plural: true\n      }\n    }\n  ]\n});\n\nconst commentStore = new MobStore({\n  collectionName: \ncomments\n,\n  type: \ncomment\n,\n  associations: [\n    {\n      key: \npost\n,\n      type: \npost\n,\n      inverse: {\n        key: \ncomments\n,\n        plural: true\n      }\n    },\n    {\n      key: \ncommenter\n,\n      type: \nperson\n,\n      inverse: {\n        key: \ncomments\n,\n        plural: true\n      }\n    }\n  ]\n});\n\nconst peopleStore = new MobStore({\n  collectionName: \npeople\n,\n  type: \nperson\n,\n  associations: [\n    {\n      key: \nposts\n,\n      type: \npost\n,\n      plural: true,\n      inverse: {\n        key: \nauthor\n\n      }\n    },\n    {\n      key: \ncomments\n,\n      type: \ncomment\n,\n      plural: true,\n      inverse: {\n        key: \ncommenter\n\n      }\n    }\n  ]\n});\n\n\n\n\nUsage\n\n\nNow, we can take some JSON data that we got from the server and inject it into our stores.\n\n\nconst dataFromServer = {\n  id: 42,\n  title: \nHow to make an app\n,\n  author: {\n    id: 12,\n    name: \nMark Twain\n\n  },\n  comments: [\n    {\n      id: 3,\n      text: \nThis article is great.\n,\n      commenter: {\n        id: 13,\n        name: \nAldous Huxley\n\n      }\n    },\n    {\n      id: 4,\n      text: \nThis article sucks.\n,\n      commenter: {\n        id: 14,\n        name: \nJared Diamond\n\n      }\n    }\n  ]\n};\n\npostStore.inject(dataFromServer);\n\n\n\n\nNotice that with the single call to \n.inject\n with the nested data, we have populated all three stores with their appropriate data, and each has the correct references to all of their associations.\n\n\npostStore.posts\n// [ {id:42, title: \nHow to make an app\n, author: {id: 12...}, comments: [...]} ]\n\npeopleStore.people\n// [\n//   {id:12, name: \nMark Twain\n, posts: [...], comments: [...]},\n//   {id:13, name: \nAldous Huxley\n, posts: [...], comments: [...]},\n//   {id:14, name: \nJared Diamond\n, posts: [...], comments: [...]},\n// ]\n\ncommentStore.comments\n// [\n//   {id: 3, text: \nThis article is great.\n, post: {id: 42,...}, author: {id: 13...}}\n//   {id: 4, text: \nThis article sucks.\n, post: {id: 42...}, author: {id: 14...}}\n// ]\n\n\n\n\nAll of the references are hooked up like you would expect.\n\n\npeopleStore.find(12).posts[0].comments[0].commenter.name\n// \nAldous Huxley\n\n\n\n\n\nUse with React\n\n\nIf you use this data store together with \nmobx-react\n, your React components will automatically re-render when you update your data by injecting more data into any of the stores, or by changing any of the scalar values of your objects.\n\n\n@observer\nclass PostsContainer extends React.Component {\n  render() {\n    return (\n      \nPostsList\n        posts={postsStore.posts}\n      /\n\n    );\n  }\n}\n\n//...\n\n\n// add a new comment. by including the ids of the associations, they will get hooked up properly.\ncommentStore.inject({\n  id: 5,\n  text: \nSpam\n,\n  post: { id: 42},\n  author: { id: 12 }\n});\n\ncommentStore.find(5).post.author.name\n// \nMark Twain\n\n\n//...\n\n// update the author's name. this will show immediately in the UI if the name field is used somewhere.\nconst mark = peopleStore.find(12);\nmark.name = \nTwark Main\n\n\n//...\n\npostStore.posts[0].author.name\n// \nTwark Main\n\n\ncommentStore.find(5).post.author.name\n// \nTwark Main", 
            "title": "Overview"
        }, 
        {
            "location": "/overview/#setup", 
            "text": "Here's an example where we set up three data stores, each with associations to the other two. Notice that we are very explicit about the associations we set up. Nothing is magic. Only the associations you define are populated.  import {MobStore} from 'mobstore';\n\nconst postStore = new MobStore({\n  collectionName:  posts ,  // the accessor, i.e. `postStore.posts`\n  type:  post ,             // this store holds items of the `post` type.\n  associations: [\n    {\n      key:  comments ,      // a post has a `myPost.comments` key\n      type:  comment ,      // this association holds items of the `comment` type.\n      plural: true,         // it's an array of them, not a single one.\n      inverse: {\n        key:  post ,        // a comment will have a `myComment.post` key\n        plural: false       // optional, false is the default\n      }\n    },\n    {\n      key:  author ,\n      type:  person ,\n      plural: false,\n      inverse: {\n        key:  posts ,\n        plural: true\n      }\n    }\n  ]\n});\n\nconst commentStore = new MobStore({\n  collectionName:  comments ,\n  type:  comment ,\n  associations: [\n    {\n      key:  post ,\n      type:  post ,\n      inverse: {\n        key:  comments ,\n        plural: true\n      }\n    },\n    {\n      key:  commenter ,\n      type:  person ,\n      inverse: {\n        key:  comments ,\n        plural: true\n      }\n    }\n  ]\n});\n\nconst peopleStore = new MobStore({\n  collectionName:  people ,\n  type:  person ,\n  associations: [\n    {\n      key:  posts ,\n      type:  post ,\n      plural: true,\n      inverse: {\n        key:  author \n      }\n    },\n    {\n      key:  comments ,\n      type:  comment ,\n      plural: true,\n      inverse: {\n        key:  commenter \n      }\n    }\n  ]\n});", 
            "title": "Setup"
        }, 
        {
            "location": "/overview/#usage", 
            "text": "Now, we can take some JSON data that we got from the server and inject it into our stores.  const dataFromServer = {\n  id: 42,\n  title:  How to make an app ,\n  author: {\n    id: 12,\n    name:  Mark Twain \n  },\n  comments: [\n    {\n      id: 3,\n      text:  This article is great. ,\n      commenter: {\n        id: 13,\n        name:  Aldous Huxley \n      }\n    },\n    {\n      id: 4,\n      text:  This article sucks. ,\n      commenter: {\n        id: 14,\n        name:  Jared Diamond \n      }\n    }\n  ]\n};\n\npostStore.inject(dataFromServer);  Notice that with the single call to  .inject  with the nested data, we have populated all three stores with their appropriate data, and each has the correct references to all of their associations.  postStore.posts\n// [ {id:42, title:  How to make an app , author: {id: 12...}, comments: [...]} ]\n\npeopleStore.people\n// [\n//   {id:12, name:  Mark Twain , posts: [...], comments: [...]},\n//   {id:13, name:  Aldous Huxley , posts: [...], comments: [...]},\n//   {id:14, name:  Jared Diamond , posts: [...], comments: [...]},\n// ]\n\ncommentStore.comments\n// [\n//   {id: 3, text:  This article is great. , post: {id: 42,...}, author: {id: 13...}}\n//   {id: 4, text:  This article sucks. , post: {id: 42...}, author: {id: 14...}}\n// ]  All of the references are hooked up like you would expect.  peopleStore.find(12).posts[0].comments[0].commenter.name\n//  Aldous Huxley", 
            "title": "Usage"
        }, 
        {
            "location": "/overview/#use-with-react", 
            "text": "If you use this data store together with  mobx-react , your React components will automatically re-render when you update your data by injecting more data into any of the stores, or by changing any of the scalar values of your objects.  @observer\nclass PostsContainer extends React.Component {\n  render() {\n    return (\n       PostsList\n        posts={postsStore.posts}\n      / \n    );\n  }\n}\n\n//...\n\n\n// add a new comment. by including the ids of the associations, they will get hooked up properly.\ncommentStore.inject({\n  id: 5,\n  text:  Spam ,\n  post: { id: 42},\n  author: { id: 12 }\n});\n\ncommentStore.find(5).post.author.name\n//  Mark Twain \n\n//...\n\n// update the author's name. this will show immediately in the UI if the name field is used somewhere.\nconst mark = peopleStore.find(12);\nmark.name =  Twark Main \n\n//...\n\npostStore.posts[0].author.name\n//  Twark Main \n\ncommentStore.find(5).post.author.name\n//  Twark Main", 
            "title": "Use with React"
        }, 
        {
            "location": "/class_example/", 
            "text": "ES6 Class example\n\n\nHere's an example of how you could use an ES6 subclass of \nMobStore\n for a data store.\n\n\nThis also shows how you can add instance methods to the items that you inject into the store.\n\n\nimport {computed} from 'mobx';\nimport {MobStore} from 'mobstore';\nimport api from 'fictional-api'; // MobStore does not do any network requests.\n\nclass ItemStore extends MobStore {\n\n  constructor() {\n    super({\n      collectionName: 'items',\n      type: 'item',\n      instanceMethods: {\n        // as part of `inject`ing the objects into the store, MobStore sets up a\n        // prototype for each, using these methods.\n        isNew() {\n          return this.created_at \n 10.days.ago // pseudo-code but you get the idea.\n        }\n      }\n    });\n\n    extendObservable(this, {\n      progress: false,\n      errorMessage: null\n    });\n  }\n\n  // use itemStore.newItems in a view. Then, whenever any item's data is updated,\n  // this will automatically recompute and re-render your view, if the result\n  // of this filtered list changed.\n  @computed get newItems() {\n    return this.items.filter((item) =\n {\n      return item.isNew();\n    });\n  }\n\n  // call this whenever you want to get new items from the server, or update with\n  // any changes since you last checked.\n  fetchAllItems() {\n    api.get('/items.json')\n      .then(({data}) =\n {\n        this.inject(data); // assuming data is an array of item objects, or a single object\n      })\n  }\n\n  // here is your flux async action. it's much simpler now, with mobx and mobstore.\n  // this method is the \naction creator\n. to create the action, just call the method.\n  // setting the data is your \nreducer\n -- it changes the data. The UI is updated automatically.\n  createItem(some_form_data) {\n    this.progress = true;\n    api.post('/items', some_form_data)\n      .then(({data}) =\n {\n        this.inject(data);\n        this.progress = false;\n        this.errorMessage = null;\n      })\n      .catch(({errorMessage}) =\n {\n        this.progress = false;\n        this.errorMessage = errorMessage;\n      });\n  }\n\n}\n\n//...\n\nconst itemStore = new ItemStore();\n\n//...\n\n\n\n\nReact Component\n\n\nHere's how you could use the reactive data from the store above in a React component. Notice how we just supply the \nitemStore\n's computed/observable values directly. There is no other boilerplate needed. Hook up a form submission to the \ncreateItem\n method and watch your list view update automatically.\n\n\nIn real life you'd probably only want the parent \"container component\" to import and use the store directly. See \nContainer Components\n.\n\n\n\n@observer\nclass NewItemList extends React.Component {\n  renderItem(item) {\n    return (\n      \nItem item={item} /\n\n    );\n  }\n\n  render() {\n    return (\n      \ndiv\n\n        \nProgressSpinner visible={itemStore.progress} /\n\n        \nErrorMessage\n          visible={itemStore.errorMessage \n itemStore.errorMessage.length}\n          message={itemStore.errorMessage} /\n\n        {itemStore.newItems.map(this.renderItem)}\n      \n/div\n\n    );\n  }\n}", 
            "title": "Class Example"
        }, 
        {
            "location": "/class_example/#es6-class-example", 
            "text": "Here's an example of how you could use an ES6 subclass of  MobStore  for a data store.  This also shows how you can add instance methods to the items that you inject into the store.  import {computed} from 'mobx';\nimport {MobStore} from 'mobstore';\nimport api from 'fictional-api'; // MobStore does not do any network requests.\n\nclass ItemStore extends MobStore {\n\n  constructor() {\n    super({\n      collectionName: 'items',\n      type: 'item',\n      instanceMethods: {\n        // as part of `inject`ing the objects into the store, MobStore sets up a\n        // prototype for each, using these methods.\n        isNew() {\n          return this.created_at   10.days.ago // pseudo-code but you get the idea.\n        }\n      }\n    });\n\n    extendObservable(this, {\n      progress: false,\n      errorMessage: null\n    });\n  }\n\n  // use itemStore.newItems in a view. Then, whenever any item's data is updated,\n  // this will automatically recompute and re-render your view, if the result\n  // of this filtered list changed.\n  @computed get newItems() {\n    return this.items.filter((item) =  {\n      return item.isNew();\n    });\n  }\n\n  // call this whenever you want to get new items from the server, or update with\n  // any changes since you last checked.\n  fetchAllItems() {\n    api.get('/items.json')\n      .then(({data}) =  {\n        this.inject(data); // assuming data is an array of item objects, or a single object\n      })\n  }\n\n  // here is your flux async action. it's much simpler now, with mobx and mobstore.\n  // this method is the  action creator . to create the action, just call the method.\n  // setting the data is your  reducer  -- it changes the data. The UI is updated automatically.\n  createItem(some_form_data) {\n    this.progress = true;\n    api.post('/items', some_form_data)\n      .then(({data}) =  {\n        this.inject(data);\n        this.progress = false;\n        this.errorMessage = null;\n      })\n      .catch(({errorMessage}) =  {\n        this.progress = false;\n        this.errorMessage = errorMessage;\n      });\n  }\n\n}\n\n//...\n\nconst itemStore = new ItemStore();\n\n//...", 
            "title": "ES6 Class example"
        }, 
        {
            "location": "/class_example/#react-component", 
            "text": "Here's how you could use the reactive data from the store above in a React component. Notice how we just supply the  itemStore 's computed/observable values directly. There is no other boilerplate needed. Hook up a form submission to the  createItem  method and watch your list view update automatically.  In real life you'd probably only want the parent \"container component\" to import and use the store directly. See  Container Components .  \n@observer\nclass NewItemList extends React.Component {\n  renderItem(item) {\n    return (\n       Item item={item} / \n    );\n  }\n\n  render() {\n    return (\n       div \n         ProgressSpinner visible={itemStore.progress} / \n         ErrorMessage\n          visible={itemStore.errorMessage   itemStore.errorMessage.length}\n          message={itemStore.errorMessage} / \n        {itemStore.newItems.map(this.renderItem)}\n       /div \n    );\n  }\n}", 
            "title": "React Component"
        }
    ]
}